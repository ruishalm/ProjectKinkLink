// d:\Projetos\Github\app\ProjectKinkLink\firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Função helper para verificar se o usuário autenticado é admin
    function isUserAdmin() {
      // Verifica se o usuário autenticado tem o campo isAdmin = true em seu próprio documento
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    // Regras para a coleção 'users'
    match /users/{userId} {
      // REGRA DE LEITURA TEMPORARIAMENTE SIMPLIFICADA PARA DIAGNÓSTICO
      allow get: if request.auth != null && request.auth.uid == userId;

      // Listagem (para ler a coleção inteira):
      // Apenas admins podem listar todos os usuários.
      allow list: if request.auth != null && isUserAdmin();

      // Criação (signup):
      // Usuário pode criar seu próprio documento.
      // O campo 'isAdmin' deve ser 'false' na criação. AuthContext já faz isso.
      allow create: if request.auth != null &&
                       request.auth.uid == userId &&
                       request.resource.data.isAdmin == false &&
                       // Outras validações de campos iniciais podem ser adicionadas aqui se necessário,
                       // por exemplo, garantir que o email corresponde ao token:
                       // request.resource.data.email == request.auth.token.email
                       true; // Simplificado, pois o AuthContext deve enviar os dados corretos.

      // Atualização:
      allow update: if request.auth != null && (
        // 1. Usuário atualizando seu próprio documento:
        //    - Não pode mudar seu status 'isAdmin'.
        //    - Pode atualizar outros campos permitidos (bio, username, etc.).
        (
          request.auth.uid == userId &&
          (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == resource.data.isAdmin)
          // Se quiser restringir campos que o usuário pode auto-editar, adicione:
          // && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['bio', 'username', 'unlockedSkinIds', ...])
        ) ||
        // 2. Parceiro pode atualizar campos de vínculo ('linkedPartnerId', 'coupleId') do outro usuário.
        ( // Este bloco é para o parceiro atualizar os campos de vínculo do outro usuário.
          // A parte anterior `(request.auth.uid == userId) ||` era redundante com a condição 1.
          request.auth.uid != userId && // O requisitante não é o dono do documento
          request.resource.data.linkedPartnerId == request.auth.uid && // O campo linkedPartnerId no doc sendo atualizado aponta para o requisitante
          (request.resource.data.coupleId == resource.data.coupleId || request.resource.data.coupleId is string) && // Consistência do coupleId
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['linkedPartnerId', 'coupleId']) // Apenas estes campos podem ser alterados
        ) ||
        // 3. Parceiro pode atualizar o array 'seenCards' do outro usuário.
        ( // Este bloco era anteriormente para campos de vínculo também (mal rotulado). Corrigindo para 'seenCards'.
          request.method == 'update' &&
          request.auth.uid != userId && // O requisitante não é o dono do documento
          get(/databases/$(database)/documents/users/$(userId)).data.linkedPartnerId == request.auth.uid && // O documento sendo atualizado pertence ao parceiro atual do requisitante
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['seenCards']) // Apenas o campo 'seenCards' pode ser alterado nesta condição
        ) ||
        // 4. Admin pode atualizar campos específicos de OUTRO usuário (e.g., 'isSupporter', 'bio').
        //    - Não pode mudar 'isAdmin' de outro usuário por esta regra (isso deve ser feito no console do Firebase).
        ( // Este bloco é para o admin atualizar outros usuários.
          isUserAdmin() &&
          userId != request.auth.uid && // Garante que o admin está atualizando OUTRO usuário
          (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == resource.data.isAdmin) && // Admin não pode mudar isAdmin de outros
          request.resource.data.diff(resource.data).affectedKeys().hasAny(['isSupporter', 'bio', 'username', 'unlockedSkinIds' /* adicione outros campos que o admin pode editar */])
        ) ||
        // 5. Admin atualizando seu PRÓPRIO documento (pode mudar seu próprio isAdmin, por exemplo, para se remover de admin).
        (
          isUserAdmin() &&
          userId == request.auth.uid // Admin está atualizando seu próprio documento
        )
      );
      // Deleção: Apenas admins podem deletar usuários. (Se não quiser permitir, mude para 'if false;')
      allow delete: if request.auth != null && isUserAdmin();
    }

    // Regras para a coleção 'pendingLinks'
    match /pendingLinks/{linkCode} {
      allow read: if request.auth != null &&
                     (resource.data.initiatorUserId == request.auth.uid ||
                      (resource.data.status == 'pending' || resource.data.status == 'cancelled_initiator_linked' || resource.data.status == 'expired') ||
                      (resource.data.status == 'completed' && resource.data.acceptedBy == request.auth.uid)
                     );
      allow create: if request.auth != null && request.resource.data.initiatorUserId == request.auth.uid &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.linkCode == linkCode &&
                       request.resource.data.keys().hasAll(['initiatorUserId', 'linkCode', 'status', 'createdAt']) &&
                       request.resource.data.keys().hasOnly(['initiatorUserId', 'linkCode', 'status', 'createdAt']);
      allow update: if request.auth != null &&
                       resource.data.initiatorUserId != request.auth.uid && 
                       resource.data.status == 'pending' &&
                       (
                         (request.resource.data.status == 'completed' &&
                          request.resource.data.acceptedBy == request.auth.uid &&
                          request.resource.data.coupleId is string &&
                          request.resource.data.initiatorUserId == resource.data.initiatorUserId &&
                          request.resource.data.linkCode == resource.data.linkCode &&
                          request.resource.data.createdAt == resource.data.createdAt) ||
                         ((request.resource.data.status == 'cancelled_initiator_linked' || request.resource.data.status == 'expired') &&
                          !('acceptedBy' in request.resource.data) &&
                          !('coupleId' in request.resource.data) &&
                          request.resource.data.initiatorUserId == resource.data.initiatorUserId)
                       );
    }
    
    // Regras para a coleção 'linkRequests' (Se ainda estiver em uso, caso contrário, pode ser removida)
    match /linkRequests/{requestId} {
        allow read: if request.auth != null && 
                       (resource.data.requesterId == request.auth.uid || resource.data.targetId == request.auth.uid);
        allow create: if request.auth != null && request.resource.data.requesterId == request.auth.uid;
        allow delete: if request.auth != null && 
                       (resource.data.requesterId == request.auth.uid || resource.data.targetId == request.auth.uid); 
    }

    // Regras para a coleção 'couples'
    match /couples/{coupleId} {
      allow create: if request.auth != null &&
                       request.resource.data.members.size() == 2 &&
                       request.auth.uid in request.resource.data.members &&
                       request.resource.data.members[0] is string &&
                       request.resource.data.members[1] is string &&
                       request.resource.data.createdAt == request.time;

      // Helper function para verificar se o usuário autenticado é membro deste casal
      function isUserMemberOfCouple() {
        // Revertendo para usar o coupleId do escopo do match
        let couplePath = /databases/$(database)/documents/couples/$(coupleId);
        return exists(couplePath) &&
               get(couplePath).data.members is list && // Garante que 'members' existe e é uma lista
               request.auth.uid in get(couplePath).data.members; // Verifica se o UID está na lista
      }
      allow read, update, delete: if request.auth != null && isUserMemberOfCouple();
      
      // Regras para a subcoleção 'likedInteractions'
      match /likedInteractions/{cardId} {
        // Restaurando a verificação de membro para leitura
        allow read: if request.auth != null && isUserMemberOfCouple(); 
        
        allow create: if request.auth != null && isUserMemberOfCouple() &&
                        request.resource.data.likedByUIDs.size() == 1 &&
                        request.resource.data.likedByUIDs[0] == request.auth.uid &&
                        request.resource.data.isMatch == false &&
                        request.resource.data.keys().hasAll(['cardData', 'likedByUIDs', 'isMatch', 'isHot', 'lastActivity', 'createdAt']);
        
        allow update: if request.auth != null && isUserMemberOfCouple() &&
                         (
                           ( // Caso 1: Segundo usuário curte, formando um match
                             resource.data.likedByUIDs.size() == 1 &&
                             !(request.auth.uid in resource.data.likedByUIDs) &&
                             request.resource.data.likedByUIDs.size() == 2 &&
                             request.resource.data.likedByUIDs[0] == resource.data.likedByUIDs[0] && 
                             request.resource.data.likedByUIDs[1] == request.auth.uid &&          
                             request.resource.data.isMatch == true &&
                             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likedByUIDs', 'isMatch', 'lastActivity'])
                           ) ||
                           ( // Caso 2: Alternando 'isHot' em um match existente
                             resource.data.isMatch == true &&
                             request.resource.data.isMatch == true && 
                             request.resource.data.likedByUIDs == resource.data.likedByUIDs && 
                             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isHot', 'lastActivity'])
                           )
                         );
        
        allow delete: if request.auth != null && isUserMemberOfCouple();
      }

      // Regras para a subcoleção 'cardChats' (chats de cada carta com match)
      match /cardChats/{cardId_do_match} {
        // Restaurando a verificação de membro para leitura e delete
        allow read, delete: if request.auth != null && isUserMemberOfCouple();

        // Permite a criação do documento do chat se o usuário for membro.
        // Os campos como lastMessage... serão definidos através de uma operação de update (set com merge).
        allow create: if request.auth != null && isUserMemberOfCouple();

        // Permite a atualização dos detalhes da última mensagem.
        allow update: if request.auth != null && isUserMemberOfCouple() &&
                         request.resource.data.lastMessageSenderId == request.auth.uid && // Garante que quem está atualizando é o remetente da "última mensagem"
                         request.resource.data.lastMessageTimestamp is timestamp &&
                         // Verifica se os campos que estão sendo escritos são apenas os permitidos
                         request.writeFields.hasOnly(['lastMessageSenderId', 'lastMessageTimestamp', 'lastMessageTextSnippet']);

        match /messages/{messageId} {
          allow read: if request.auth != null && isUserMemberOfCouple();
          allow create: if request.auth != null && 
                        isUserMemberOfCouple() &&
                        request.resource.data.userId == request.auth.uid && 
                        request.resource.data.keys().hasAll(['userId', 'username', 'text', 'timestamp']);
                        // request.resource.data.timestamp == request.time; // TEMPORARIAMENTE COMENTADO PARA TESTE
          allow update, delete: if false; 
        }
      }
    }
    
    // Regras para a coleção 'userCards'
    match /userCards/{userCardId} {
      function isMemberOfTheCoupleForUserCard(coupleDocId) {
        let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
        return userDoc.data != null && userDoc.data.coupleId != null && userDoc.data.coupleId == coupleDocId;
      }
      allow create: if request.auth != null &&
                       isMemberOfTheCoupleForUserCard(request.resource.data.coupleId);
      allow read, update, delete: if request.auth != null && 
                                     isMemberOfTheCoupleForUserCard(resource.data.coupleId);
    }

    // Regra para a coleção 'cards'
    match /cards/{cardId} {
      allow read: if request.auth != null;
      allow write, delete: if false;
    }

    // Regras para a ANTIGA coleção 'cardChats' (COMENTAR OU REMOVER SE NÃO ESTIVER MAIS EM USO)
    /*
    match /cardChats/{chatRoomId}/messages/{messageId} {
        function isChatMember(chatRoomDocId) {
            let parts = chatRoomDocId.split('_');
            return request.auth.uid == parts[1] || request.auth.uid == parts[2];
        }
        allow read: if request.auth != null && isChatMember(chatRoomId);
        allow create: if request.auth != null && 
                         isChatMember(chatRoomId) &&
                         request.resource.data.userId == request.auth.uid; 
        allow update, delete: if false;
    }
    */
  }

}
